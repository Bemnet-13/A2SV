# Problem: Minimize Malware Spread - https://leetcode.com/problems/minimize-malware-spread/

class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        mat = graph
        graph = defaultdict(list)
        n = len(mat)
        initial = set(initial)

        for i in range(n):
            for j in range(n):
                if i > j and mat[i][j] == 1:
                    graph[i].append(j)
                    graph[j].append(i)
        # How large the current component is
        # Is there any infected node in the component and how many
        # If there are multiple infected nodes, what is the smallest infected node in the component
        size = 0
        infected = []
        visited = [False for _ in range(n)]
        
        def dfs(node):
            nonlocal size
            nonlocal infected
            nonlocal visited
            size += 1
            if node in initial:
                infected.append(node)
            visited[node] = True

            for neighbor in graph[node]:
                if not visited[neighbor]:
                    dfs(neighbor)

        real_ans = n + 1, -1
        dup_ans = n + 1

        for i in range(n):
            if not visited[i]:
                dfs(i)
                if size > real_ans[1] and len(infected) == 1:
                    print(size, infected)
                    real_ans = infected[0], size
                elif size == real_ans[1] and len(infected) == 1:
                    real_ans = min(infected[0], real_ans[0]), size

                elif len(infected) > 1:
                    dup_ans = min(min(infected), dup_ans)
            size = 0
            infected = []
        
        if real_ans[1] != -1:
            return real_ans[0]
        return dup_ans

